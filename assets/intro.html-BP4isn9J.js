import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as e,o as n}from"./app-DRK0NY4d.js";const l={};function a(r,i){return n(),t("div",null,i[0]||(i[0]=[e(`<h1 id="windows-驱动开发基础" tabindex="-1"><a class="header-anchor" href="#windows-驱动开发基础"><span>Windows 驱动开发基础</span></a></h1><p>驱动程序通过<strong>主功能函数 (Major Functions)</strong> 提供输入/输出 (I/O) 例程。Windows 驱动开发套件 (WDK) 定义了 28 种主功能函数，包括：</p><ul><li>设备创建 (<code>IRP_MJ_CREATE</code>)</li><li>关闭 (<code>IRP_MJ_CLOSE</code>)</li><li>电源管理 (<code>IRP_MJ_POWER</code>)</li><li>I/O 控制 (<code>IRP_MJ_DEVICE_CONTROL</code>)</li><li>读/写 (<code>IRP_MJ_READ</code>/<code>IRP_MJ_WRITE</code>)</li><li>信息查询/设置 (<code>IRP_MJ_QUERY_INFORMATION</code>/<code>IRP_MJ_SET_INFORMATION</code>)</li><li>系统关机 (<code>IRP_MJ_SHUTDOWN</code>)<br><em>(补充：其他主函数如清理<code>IRP_MJ_CLEANUP</code>、即插即用<code>IRP_MJ_PNP</code>等)</em></li></ul><p>当驱动程序初始化时，其 <strong>_DRIVER_OBJECT</strong> 结构体会注册这些主功能的处理例程。该结构包含驱动关键信息：</p><ul><li>驱动名称</li><li>关联设备的链表</li><li>卸载回调函数（响应驱动卸载请求）</li><li>驱动的内存边界（起始地址与大小）</li></ul><p>驱动程序可创建 <strong>_DEVICE_OBJECT</strong> 结构体表示其管理的设备。<strong>设备不一定对应真实硬件</strong>（补充：例如虚拟设备）。以 Sysinternals Process Explorer 为例：</p><ol><li>工具启动时加载微软签名的驱动</li><li>通过用户态 API 与驱动通信</li><li>驱动创建<strong>用户态可访问的设备对象</strong></li><li>内核 I/O 系统将用户请求派发到设备所属驱动的对应主功能处理例程</li></ol><hr><h3 id="主功能处理机制" tabindex="-1"><a class="header-anchor" href="#主功能处理机制"><span>主功能处理机制</span></a></h3><p>主功能代码是 WDK 头文件中定义的整型常量，符号名均以 <strong><code>IRP_MJ_</code></strong> 开头（如 <code>IRP_MJ_DEVICE_CONTROL=14</code>）。它们在 <strong>_DRIVER_OBJECT</strong> 的主功能数组中的偏移量从 <strong>0x70</strong> 开始。主功能处理例程（亦称驱动分发例程）原型如下：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">NTSTATUS </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">DriverDispatch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    _DEVICE_OBJECT </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">DeviceObject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 目标设备对象</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    _IRP </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Irp</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                     // I/O请求包</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ ... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="i-o-请求包-irp-解析" tabindex="-1"><a class="header-anchor" href="#i-o-请求包-irp-解析"><span>I/O 请求包 (IRP) 解析</span></a></h3><p>IRP 描述对设备的 I/O 请求，关键字段包括：</p><ol><li><p><strong><code>AssociatedIrp.SystemBuffer</code></strong></p><ul><li>通常包含请求的输入/输出缓冲区</li><li><em>(补充：适用于缓冲I/O模式，内核会复制用户态数据)</em></li></ul></li><li><p><strong><code>Tail.Overlay.CurrentStackLocation</code></strong></p><ul><li>指向当前设备栈层的 <strong>_IO_STACK_LOCATION</strong> 结构</li><li>包含<strong>设备相关</strong>的请求信息： <ul><li><strong><code>MajorFunction</code></strong>：当前主功能代码（如 <code>IRP_MJ_DEVICE_CONTROL</code>）</li><li><strong><code>Parameters</code></strong>：根据主功能变化的联合体</li></ul></li></ul></li></ol><hr><h3 id="设备控制请求-ioctl-专项说明" tabindex="-1"><a class="header-anchor" href="#设备控制请求-ioctl-专项说明"><span>设备控制请求 (IOCTL) 专项说明</span></a></h3><p>当 <code>MajorFunction = IRP_MJ_DEVICE_CONTROL (14)</code> 时：</p><ul><li><strong><code>Parameters.DeviceIoControl</code></strong> 子结构生效：<div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  ULONG IoControlCode;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // IOCTL控制码</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  PVOID InputBuffer;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 输入缓冲区地址</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  ULONG InputBufferLength;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  PVOID OutputBuffer;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 输出缓冲区地址</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  ULONG OutputBufferLength;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><strong>输入/输出缓冲区</strong>通常通过 <code>Irp-&gt;AssociatedIrp.SystemBuffer</code> 传递<br><em>(补充：直接I/O模式使用<code>Irp-&gt;MdlAddress</code>映射物理内存)</em></li></ul><hr><h3 id="ioctl-控制码深度解析" tabindex="-1"><a class="header-anchor" href="#ioctl-控制码深度解析"><span>IOCTL 控制码深度解析</span></a></h3><p>IOCTL 代码是 32 位位掩码，包含四部分信息（以 <code>0x222000</code> 为例）：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" data-title="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CTL_CODE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">DeviceType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Function</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Access</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><table><thead><tr><th>字段</th><th>位域</th><th>示例值</th><th>说明</th></tr></thead><tbody><tr><td><strong>设备类型</strong></td><td>31-16</td><td>0x22</td><td>自定义设备类型标识符</td></tr><tr><td><strong>功能代码</strong></td><td>15-2</td><td>0x200</td><td>操作编号（0x800+为自定义）</td></tr><tr><td><strong>缓冲方式</strong></td><td>1-0</td><td>0x00</td><td><code>METHOD_BUFFERED</code>(0) 最常用</td></tr><tr><td><strong>访问权限</strong></td><td>31-30</td><td>0x2</td><td><code>FILE_WRITE_ACCESS</code>(2)</td></tr></tbody></table><p><em>(补充：缓冲方式决定了内核如何传递用户态数据，METHOD_IN_DIRECT等模式需配合MDL使用)</em></p><blockquote><p>完整 IOCTL 规范参考：<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/defining-i-o-control-codes" target="_blank" rel="noopener noreferrer">Microsoft Docs - Defining I/O Control Codes</a></p></blockquote>`,26)]))}const h=s(l,[["render",a],["__file","intro.html.vue"]]),c=JSON.parse('{"path":"/Operating_Systems/ntoskrnl/driver/intro.html","title":"Windows 驱动开发基础","lang":"zh-CN","frontmatter":{"description":"Windows 驱动开发基础 驱动程序通过主功能函数 (Major Functions) 提供输入/输出 (I/O) 例程。Windows 驱动开发套件 (WDK) 定义了 28 种主功能函数，包括： 设备创建 (IRP_MJ_CREATE) 关闭 (IRP_MJ_CLOSE) 电源管理 (IRP_MJ_POWER) I/O 控制 (IRP_MJ_DE...","head":[["meta",{"property":"og:url","content":"https://ccoskrnl.github.io/notes/notes/Operating_Systems/ntoskrnl/driver/intro.html"}],["meta",{"property":"og:site_name","content":"Notes"}],["meta",{"property":"og:title","content":"Windows 驱动开发基础"}],["meta",{"property":"og:description","content":"Windows 驱动开发基础 驱动程序通过主功能函数 (Major Functions) 提供输入/输出 (I/O) 例程。Windows 驱动开发套件 (WDK) 定义了 28 种主功能函数，包括： 设备创建 (IRP_MJ_CREATE) 关闭 (IRP_MJ_CLOSE) 电源管理 (IRP_MJ_POWER) I/O 控制 (IRP_MJ_DE..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-10T19:01:15.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-10T19:01:15.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Windows 驱动开发基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-10T19:01:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"城城\\",\\"url\\":\\"https://ccoskrnl.github.io/notes/\\"}]}"]],"date":"2025-08-10T19:01:15.000Z"},"headers":[{"level":3,"title":"主功能处理机制","slug":"主功能处理机制","link":"#主功能处理机制","children":[]},{"level":3,"title":"I/O 请求包 (IRP) 解析","slug":"i-o-请求包-irp-解析","link":"#i-o-请求包-irp-解析","children":[]},{"level":3,"title":"设备控制请求 (IOCTL) 专项说明","slug":"设备控制请求-ioctl-专项说明","link":"#设备控制请求-ioctl-专项说明","children":[]},{"level":3,"title":"IOCTL 控制码深度解析","slug":"ioctl-控制码深度解析","link":"#ioctl-控制码深度解析","children":[]}],"git":{"createdTime":1754852475000,"updatedTime":1754852475000,"contributors":[{"name":"chengcheng","username":"chengcheng","email":"2010705797@qq.com","commits":1,"url":"https://github.com/chengcheng"}]},"readingTime":{"minutes":2.45,"words":736},"filePathRelative":"Operating_Systems/ntoskrnl/driver/intro.md","localizedDate":"2025年8月10日","excerpt":"","autoDesc":true}');export{h as comp,c as data};
