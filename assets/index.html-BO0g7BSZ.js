import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as i,b as l,d as a,e as s,f as e,r as d,o as p}from"./app-C08GgaCK.js";const m={};function u(h,n){const t=d("RouteLink");return p(),r("div",null,[n[19]||(n[19]=i('<h1 id="城城的笔记" tabindex="-1"><a class="header-anchor" href="#城城的笔记"><span>城城的笔记</span></a></h1><h2 id="compiler" tabindex="-1"><a class="header-anchor" href="#compiler"><span>Compiler</span></a></h2><h3 id="分析基础" tabindex="-1"><a class="header-anchor" href="#分析基础"><span>分析基础</span></a></h3><hr><h4 id="静态单赋值形式-static-single-assignment-ssa" tabindex="-1"><a class="header-anchor" href="#静态单赋值形式-static-single-assignment-ssa"><span>静态单赋值形式(Static Single Assignment (SSA))</span></a></h4><p>这篇文章简要介绍了静态单赋值(Static Single Assignment (SSA))的作用，以及它的计算方法。并给出了最小化SSA算法实现。</p>',6)),l("ul",null,[l("li",null,[a(t,{to:"/Compiler/basics/ssa/ssa.html"},{default:s(()=>n[0]||(n[0]=[e("静态单赋值形式(Static Single Assignment (SSA))")])),_:1})])]),n[20]||(n[20]=l("h4",{id:"格论-lattice-theory",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#格论-lattice-theory"},[l("span",null,"格论(Lattice Theory)")])],-1)),n[21]||(n[21]=l("p",null,"格论是信息流分析的基础。在编译优化领域，格论是数据流分析的基础，许多分析技术都建立在格论之上。这篇文章首先简单的回顾了偏序，哈斯图，拓扑排序等基础。然后开始介绍格的概念，并讨论格论在数据流分析中的作用。",-1)),l("ul",null,[l("li",null,[a(t,{to:"/Compiler/basics/lattice/lattice_theory.html"},{default:s(()=>n[1]||(n[1]=[e("格论(Lattice Theory)")])),_:1})])]),n[22]||(n[22]=l("h4",{id:"常量传播中的常量格",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#常量传播中的常量格"},[l("span",null,"常量传播中的常量格")])],-1)),n[23]||(n[23]=l("p",null,"常量格是格论在编译优化中的应用之一，同时也是常量传播的基础，常量格的单调性使得常量传播分析的收敛性得到保证。",-1)),l("ul",null,[l("li",null,[a(t,{to:"/Compiler/basics/lattice/constlat.html"},{default:s(()=>n[2]||(n[2]=[e("常量传播中的常量格")])),_:1})])]),n[24]||(n[24]=l("h3",{id:"数据流分析",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#数据流分析"},[l("span",null,"数据流分析")])],-1)),n[25]||(n[25]=l("hr",null,null,-1)),n[26]||(n[26]=l("h4",{id:"单调数据流分析框架",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#单调数据流分析框架"},[l("span",null,"单调数据流分析框架")])],-1)),n[27]||(n[27]=l("p",null,[e("这篇文章主要是对 "),l("code",null,"Kam, J.B. and Jeffrey D. Ullman. Monotone Data Flow Analysis Frameworks, Tech. Rept. No. 169, Dept, of Elec. Engg., Princeton Univ., Princeton, NJ, 1975. "),e(" 的原论文进行了一些补充，在较难以理解的地方添加了注解。")],-1)),l("ul",null,[n[4]||(n[4]=l("li",null,[l("p",null,[l("a",{href:"https://github.com/ccoskrnl/notes/blob/main/docs/Compiler/data_flow_analysis/monotone/monotone_data_flow_analysis_frameworks.html",target:"_blank",rel:"noopener noreferrer"},"单调数据流分析框架 HTML版本")])],-1)),n[5]||(n[5]=l("li",null,[l("p",null,[l("a",{href:"https://github.com/ccoskrnl/notes/blob/main/docs/Compiler/data_flow_analysis/monotone/monotone_data_flow_analysis_frameworks.pdf",target:"_blank",rel:"noopener noreferrer"},"单调数据流分析框架 PDF版本")])],-1)),l("li",null,[l("p",null,[a(t,{to:"/Compiler/data_flow_analysis/monotone/monotone_data_flow_analysis_frameworks.html"},{default:s(()=>n[3]||(n[3]=[e("单调数据流分析框架 Markdown版本")])),_:1})])])]),n[28]||(n[28]=l("h4",{id:"数据流分析基础",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#数据流分析基础"},[l("span",null,"数据流分析基础")])],-1)),n[29]||(n[29]=l("p",null,"数据流分析指的是一组用来获取有关数据如何沿着程序执行路径流动的相关信息的技术。",-1)),l("ul",null,[l("li",null,[a(t,{to:"/Compiler/data_flow_analysis/intro/intro.html"},{default:s(()=>n[6]||(n[6]=[e("数据流分析基础")])),_:1})])]),n[30]||(n[30]=i('<h4 id="到达定值" tabindex="-1"><a class="header-anchor" href="#到达定值"><span>到达定值</span></a></h4><p>到达定值是最常见和有用的数据流模式之一。只要知道当控制到达程序中每个点的时候，每个变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 可能在程序中的哪些地方被定值，我们就可以确定很多有关 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 的性质。</p>',2)),l("ul",null,[l("li",null,[a(t,{to:"/Compiler/data_flow_analysis/reaching_definitions/reaching_definitions.html"},{default:s(()=>n[7]||(n[7]=[e("到达定值")])),_:1})])]),n[31]||(n[31]=l("h3",{id:"符号执行-symbolic-execution",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#符号执行-symbolic-execution"},[l("span",null,"符号执行(Symbolic Execution)")])],-1)),n[32]||(n[32]=l("hr",null,null,-1)),n[33]||(n[33]=l("h4",{id:"稀疏条件常量传播-sparse-conditional-constant-propagation",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#稀疏条件常量传播-sparse-conditional-constant-propagation"},[l("span",null,"稀疏条件常量传播(Sparse Conditional Constant Propagation)")])],-1)),l("ul",null,[l("li",null,[a(t,{to:"/Compiler/symbolic_execution/sccp/sccp.html"},{default:s(()=>n[8]||(n[8]=[e("稀疏条件常量传播(Sparse Conditional Constant Propagation)")])),_:1})])]),n[34]||(n[34]=i('<h2 id="计算机系统" tabindex="-1"><a class="header-anchor" href="#计算机系统"><span>计算机系统</span></a></h2><h3 id="计算机存储结构" tabindex="-1"><a class="header-anchor" href="#计算机存储结构"><span>计算机存储结构</span></a></h3><hr><h4 id="pcie内存获取技术" tabindex="-1"><a class="header-anchor" href="#pcie内存获取技术"><span>PCIe内存获取技术</span></a></h4><p>这篇文章简要介绍了现代计算机的内存组织结构，并对PCIe的一些技术细节进行了讲解。</p>',5)),l("ul",null,[l("li",null,[a(t,{to:"/Computer_Systems/storage/pcie_memory_acquisition/pcie_memory_acquistion.html"},{default:s(()=>n[9]||(n[9]=[e("PCIe内存获取技术")])),_:1})])]),n[35]||(n[35]=l("h3",{id:"multiple-processor-management",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#multiple-processor-management"},[l("span",null,"Multiple-Processor Management")])],-1)),n[36]||(n[36]=l("hr",null,null,-1)),n[37]||(n[37]=l("h4",{id:"locked-atomic-operations-in-ia-32",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#locked-atomic-operations-in-ia-32"},[l("span",null,"Locked atomic operations in IA-32")])],-1)),l("ul",null,[l("li",null,[a(t,{to:"/Computer_Systems/smp/atomic/atomic.html"},{default:s(()=>n[10]||(n[10]=[e("Locked atomic operations in IA-32")])),_:1})])]),n[38]||(n[38]=l("h3",{id:"uefi",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#uefi"},[l("span",null,"UEFI")])],-1)),n[39]||(n[39]=l("hr",null,null,-1)),n[40]||(n[40]=l("h4",{id:"构建edk2开发环境",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#构建edk2开发环境"},[l("span",null,"构建EDK2开发环境")])],-1)),l("ul",null,[l("li",null,[a(t,{to:"/Computer_Systems/uefi/edk2/main.html"},{default:s(()=>n[11]||(n[11]=[e("Build EDK2 development environment")])),_:1})])]),n[41]||(n[41]=i('<h2 id="操作系统内核" tabindex="-1"><a class="header-anchor" href="#操作系统内核"><span>操作系统内核</span></a></h2><h3 id="ntoskrnl" tabindex="-1"><a class="header-anchor" href="#ntoskrnl"><span>ntoskrnl</span></a></h3><hr><h4 id="windows-apc" tabindex="-1"><a class="header-anchor" href="#windows-apc"><span>Windows APC</span></a></h4><p>基于WRK(Windows Research Kernel)源代码讲解，它们很可能(或者一定)与当前版本的Windows系统有所不同。仅作为参考。</p>',5)),l("ul",null,[l("li",null,[a(t,{to:"/Operating_Systems/ntoskrnl/apc/apc.html"},{default:s(()=>n[12]||(n[12]=[e("Windows APC")])),_:1})])]),n[42]||(n[42]=l("h4",{id:"对象管理",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#对象管理"},[l("span",null,"对象管理")])],-1)),n[43]||(n[43]=l("p",null,"基于WRK对ntoskrnl的对象管理机制的简单介绍",-1)),l("ul",null,[l("li",null,[a(t,{to:"/Operating_Systems/ntoskrnl/object/object.html"},{default:s(()=>n[13]||(n[13]=[e("对象管理")])),_:1})])]),n[44]||(n[44]=l("h4",{id:"句柄",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#句柄"},[l("span",null,"句柄")])],-1)),n[45]||(n[45]=l("p",null,"基于WRK对win32编程中的句柄机制的分析。windows的对象管理机制使句柄的机制在win32编程中显得极为重要。",-1)),l("ul",null,[l("li",null,[a(t,{to:"/Operating_Systems/ntoskrnl/handle/handle.html"},{default:s(()=>n[14]||(n[14]=[e("句柄")])),_:1})])]),n[46]||(n[46]=l("h4",{id:"驱动",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#驱动"},[l("span",null,"驱动")])],-1)),n[47]||(n[47]=l("p",null,"介绍Windows驱动开发",-1)),l("ul",null,[l("li",null,[a(t,{to:"/Operating_Systems/ntoskrnl/driver/intro.html"},{default:s(()=>n[15]||(n[15]=[e("驱动开发")])),_:1})])]),n[48]||(n[48]=i('<h2 id="计算机安全" tabindex="-1"><a class="header-anchor" href="#计算机安全"><span>计算机安全</span></a></h2><h3 id="软件安全" tabindex="-1"><a class="header-anchor" href="#软件安全"><span>软件安全</span></a></h3><hr><h4 id="反射dll注入" tabindex="-1"><a class="header-anchor" href="#反射dll注入"><span>反射DLL注入</span></a></h4><p>这项技术并非一个简单的“注入工具”，而是一个高级的、旨在实现深度隐蔽和持久化驻留的恶意代码框架。它的设计目标直指现代安全检测（如EDR、AV）的盲区。</p>',5)),l("ul",null,[l("li",null,[a(t,{to:"/Computer_Security/software/reflective_dll/main.html"},{default:s(()=>n[16]||(n[16]=[e("反射DLL注入")])),_:1})])]),n[49]||(n[49]=i('<h2 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络"><span>计算机网络</span></a></h2><h3 id="sdn" tabindex="-1"><a class="header-anchor" href="#sdn"><span>SDN</span></a></h3><hr><h4 id="sdn-1" tabindex="-1"><a class="header-anchor" href="#sdn-1"><span>SDN</span></a></h4><p>软件定义网络（ SDN） 在数据平面和控制平面之间做了明确分割，在一台分离的“控制器”服务中实现了控制平面功能，该控制器服务与它所控制的路由器的转发组件完全分开并远离。</p>',5)),l("ul",null,[l("li",null,[a(t,{to:"/Computer_Networks/SDN/main.html"},{default:s(()=>n[17]||(n[17]=[e("SDN")])),_:1})])]),n[50]||(n[50]=l("h2",{id:"miscellaneous",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#miscellaneous"},[l("span",null,"Miscellaneous")])],-1)),n[51]||(n[51]=l("h3",{id:"待读清单",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#待读清单"},[l("span",null,"待读清单")])],-1)),l("ul",null,[l("li",null,[a(t,{to:"/Miscellaneous/reading_list/reading_list.html"},{default:s(()=>n[18]||(n[18]=[e("待读清单")])),_:1})])])])}const x=o(m,[["render",u],["__file","index.html.vue"]]),S=JSON.parse('{"path":"/","title":"城城的笔记","lang":"zh-CN","frontmatter":{"home":true,"layout":"BlogHome","heroFullScreen":true,"bgImage":"background.jpg","icon":"home","title":"城城的笔记","author":"城城","heroImage":"logo.png","heroText":"城城的笔记","tagline":"城城的笔记","copyright":false,"footer":"已识乾坤大，犹怜草木青","description":"城城的笔记 Compiler 分析基础 静态单赋值形式(Static Single Assignment (SSA)) 这篇文章简要介绍了静态单赋值(Static Single Assignment (SSA))的作用，以及它的计算方法。并给出了最小化SSA算法实现。 格论(Lattice Theory) 格论是信息流分析的基础。在编译优化领域，格论是...","head":[["meta",{"property":"og:url","content":"https://ccoskrnl.github.io/notes/notes/"}],["meta",{"property":"og:site_name","content":"Notes"}],["meta",{"property":"og:title","content":"城城的笔记"}],["meta",{"property":"og:description","content":"城城的笔记 Compiler 分析基础 静态单赋值形式(Static Single Assignment (SSA)) 这篇文章简要介绍了静态单赋值(Static Single Assignment (SSA))的作用，以及它的计算方法。并给出了最小化SSA算法实现。 格论(Lattice Theory) 格论是信息流分析的基础。在编译优化领域，格论是..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-07T08:11:13.000Z"}],["meta",{"property":"article:author","content":"城城"}],["meta",{"property":"article:modified_time","content":"2026-02-07T08:11:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"城城的笔记\\",\\"description\\":\\"城城的笔记 Compiler 分析基础 静态单赋值形式(Static Single Assignment (SSA)) 这篇文章简要介绍了静态单赋值(Static Single Assignment (SSA))的作用，以及它的计算方法。并给出了最小化SSA算法实现。 格论(Lattice Theory) 格论是信息流分析的基础。在编译优化领域，格论是...\\"}"]],"date":"2025-07-03T02:05:14.000Z"},"headers":[{"level":2,"title":"Compiler","slug":"compiler","link":"#compiler","children":[{"level":3,"title":"分析基础","slug":"分析基础","link":"#分析基础","children":[]},{"level":3,"title":"数据流分析","slug":"数据流分析","link":"#数据流分析","children":[]},{"level":3,"title":"符号执行(Symbolic Execution)","slug":"符号执行-symbolic-execution","link":"#符号执行-symbolic-execution","children":[]}]},{"level":2,"title":"计算机系统","slug":"计算机系统","link":"#计算机系统","children":[{"level":3,"title":"计算机存储结构","slug":"计算机存储结构","link":"#计算机存储结构","children":[]},{"level":3,"title":"Multiple-Processor Management","slug":"multiple-processor-management","link":"#multiple-processor-management","children":[]},{"level":3,"title":"UEFI","slug":"uefi","link":"#uefi","children":[]}]},{"level":2,"title":"操作系统内核","slug":"操作系统内核","link":"#操作系统内核","children":[{"level":3,"title":"ntoskrnl","slug":"ntoskrnl","link":"#ntoskrnl","children":[]}]},{"level":2,"title":"计算机安全","slug":"计算机安全","link":"#计算机安全","children":[{"level":3,"title":"软件安全","slug":"软件安全","link":"#软件安全","children":[]}]},{"level":2,"title":"计算机网络","slug":"计算机网络","link":"#计算机网络","children":[{"level":3,"title":"SDN","slug":"sdn","link":"#sdn","children":[]}]},{"level":2,"title":"Miscellaneous","slug":"miscellaneous","link":"#miscellaneous","children":[{"level":3,"title":"待读清单","slug":"待读清单","link":"#待读清单","children":[]}]}],"git":{"createdTime":1751508314000,"updatedTime":1770451873000,"contributors":[{"name":"ChengCheng","username":"ChengCheng","email":"2010705797@qq.com","commits":15,"url":"https://github.com/ChengCheng"},{"name":"chengcheng","username":"chengcheng","email":"2010705797@qq.com","commits":6,"url":"https://github.com/chengcheng"}]},"readingTime":{"minutes":3.23,"words":970},"filePathRelative":"README.md","localizedDate":"2025年7月3日","excerpt":"","autoDesc":true}');export{x as comp,S as data};
